---
import type { HTMLAttributes, HTMLTag } from "astro/types";

interface Props extends HTMLAttributes<"div"> {
    tag?: HTMLTag;
}
const props = Astro.props;

props.tag ??= "div";
props.draggable ??= "false";

const tagAttributes = { ...props };
delete tagAttributes.tag;
---

<props.tag data-grabbable {...tagAttributes}>
    <slot />
</props.tag>
<style>
    @media screen and (width > 720px) and (prefers-reduced-motion: no-preference) {
        [data-grabbable] {
            pointer-events: auto;
            cursor: grab;
        }

        [data-grabbable].grabbing {
            cursor: grabbing;
        }
    }
</style>
<script>
    import Vec2 from "@probablyduncan/common/vec2";
    import prefersReducedMotion from "../lib/prefersReducedMotion";

    function initGrabbable() {
        const grabbables: {
            el: HTMLElement;
            targetTranslate: Vec2;
            currentTranslate: Vec2;
            grabbing: boolean;
            grabStartMousePos: Vec2 | null;
            grabStartTranslatePos: Vec2 | null;
        }[] = [];

        document.querySelectorAll("[data-grabbable]").forEach((_el) => {
            const el = _el as HTMLElement;

            const info: (typeof grabbables)[number] = {
                el,
                currentTranslate: Vec2.Zero,
                targetTranslate: Vec2.Zero,
                grabbing: false,
                grabStartMousePos: null,
                grabStartTranslatePos: null,
            };

            grabbables.push(info);

            el.addEventListener("mousedown", (e) => {
                if (!userCanGrab()) return;

                info.grabbing = true;
                info.el.classList.add("grabbing");
                document.body.style.cursor = "grabbing";

                info.grabStartMousePos = Vec2.From(e.clientX, e.clientY);
                info.grabStartTranslatePos = info.currentTranslate;
            });
        });

        window.addEventListener("mouseup", () => {
            if (!userCanGrab()) return;

            document.body.style.cursor = "unset";
            grabbables.forEach((g) => {
                if (g.grabbing) {
                    g.grabbing = false;
                    g.grabStartMousePos = null;
                    g.grabStartTranslatePos = null;
                    g.el.classList.remove("grabbing");
                }
            });
        });

        window.addEventListener("mousemove", (e) => {
            if (!userCanGrab()) return;

            grabbables.forEach((g) => {
                if (
                    !g.grabbing ||
                    !g.grabStartMousePos ||
                    !g.grabStartTranslatePos
                ) {
                    return;
                }
                const newPos = Vec2.From(e.clientX, e.clientY);
                g.targetTranslate = newPos
                    .subtract(g.grabStartMousePos)
                    .add(g.grabStartTranslatePos);
            });
        });

        let prevTimeMS: DOMHighResTimeStamp = 0;
        function animate(thisTimeMS: DOMHighResTimeStamp) {
            requestAnimationFrame(animate);

            const deltaMS = thisTimeMS - prevTimeMS;
            prevTimeMS = thisTimeMS;

            const lerp = Vec2.From(Math.min(1, deltaMS * 0.0030625));
            grabbables.forEach((g) => {
                if (!g.el.style.transform) {
                    g.currentTranslate = Vec2.Zero;
                    g.targetTranslate = Vec2.Zero;
                }

                g.currentTranslate = lerp.lerp(
                    g.currentTranslate,
                    g.targetTranslate,
                );
                g.el.style.transform = `translate(${g.currentTranslate.x}px, ${g.currentTranslate.y}px)`;
            });
        }
        requestAnimationFrame(animate);

        function userCanGrab() {
            return !prefersReducedMotion() && window.innerWidth > 720;
        }
    }
    document.addEventListener("DOMContentLoaded", initGrabbable);
</script>
